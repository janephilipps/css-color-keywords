<!DOCTYPE html>
<html>
  <head>
  </head>
  <body>
    <a href=""></a>
    <br>
    <canvas width="1000" height="800" id="canvas"></canvas>
    <!-- <canvas width="150" height="150" id="aliceblue"></canvas>
    <canvas width="150" height="150" id="antiquewhite"></canvas>
    <canvas width="150" height="150" id="aqua"></canvas>
    <canvas width="150" height="150" id="aquamarine"></canvas>
    <canvas width="150" height="150" id="azure"></canvas>
    <canvas width="150" height="150" id="beige"></canvas>
    <canvas width="150" height="150" id="bisque"></canvas>
    <canvas width="150" height="150" id="black"></canvas>
    <canvas width="150" height="150" id="blanchedalmond"></canvas>
    <canvas width="150" height="150" id="blue"></canvas>
    <canvas width="150" height="150" id="blueviolet"></canvas>
    <canvas width="150" height="150" id="brown"></canvas>
    <canvas width="150" height="150" id="burlywood"></canvas>
    <canvas width="150" height="150" id="cadetblue"></canvas>
    <canvas width="150" height="150" id="chartreuse"></canvas>
    <canvas width="150" height="150" id="chocolate"></canvas>
    <canvas width="150" height="150" id="coral"></canvas>
    <canvas width="150" height="150" id="cornflowerblue"></canvas>
    <canvas width="150" height="150" id="cornsilk"></canvas>
    <canvas width="150" height="150" id="crimson"></canvas>
    <canvas width="150" height="150" id="cyan"></canvas>
    <canvas width="150" height="150" id="darkblue"></canvas>
    <canvas width="150" height="150" id="darkcyan"></canvas>
    <canvas width="150" height="150" id="darkgoldenrod"></canvas>
    <canvas width="150" height="150" id="darkgray"></canvas>
    <canvas width="150" height="150" id="darkgreen"></canvas>
    <canvas width="150" height="150" id="darkgrey"></canvas>
    <canvas width="150" height="150" id="darkkhaki"></canvas>
    <canvas width="150" height="150" id="darkmagenta"></canvas>
    <canvas width="150" height="150" id="darkolivegreen"></canvas>
    <canvas width="150" height="150" id="darkorange"></canvas>
    <canvas width="150" height="150" id="darkorchid"></canvas>
    <canvas width="150" height="150" id="darkred"></canvas>
    <canvas width="150" height="150" id="darksalmon"></canvas>
    <canvas width="150" height="150" id="darkseagreen"></canvas>
    <canvas width="150" height="150" id="darkslateblue"></canvas>
    <canvas width="150" height="150" id="darkslategray"></canvas>
    <canvas width="150" height="150" id="darkslategrey"></canvas>
    <canvas width="150" height="150" id="darkturquoise"></canvas>
    <canvas width="150" height="150" id="darkviolet"></canvas>
    <canvas width="150" height="150" id="deeppink"></canvas>
    <canvas width="150" height="150" id="deepskyblue"></canvas>
    <canvas width="150" height="150" id="dimgray"></canvas>
    <canvas width="150" height="150" id="dimgrey"></canvas>
    <canvas width="150" height="150" id="dodgerblue"></canvas>
    <canvas width="150" height="150" id="firebrick"></canvas>
    <canvas width="150" height="150" id="floralwhite"></canvas>
    <canvas width="150" height="150" id="forestgreen"></canvas>
    <canvas width="150" height="150" id="fuchsia"></canvas>
    <canvas width="150" height="150" id="gainsboro"></canvas>
    <canvas width="150" height="150" id="ghostwhite"></canvas>
    <canvas width="150" height="150" id="gold"></canvas>
    <canvas width="150" height="150" id="goldenrod"></canvas>
    <canvas width="150" height="150" id="gray"></canvas>
    <canvas width="150" height="150" id="green"></canvas>
    <canvas width="150" height="150" id="greenyellow"></canvas>
    <canvas width="150" height="150" id="grey"></canvas>
    <canvas width="150" height="150" id="honeydew"></canvas>
    <canvas width="150" height="150" id="hotpink"></canvas>
    <canvas width="150" height="150" id="indianred"></canvas>
    <canvas width="150" height="150" id="indigo"></canvas>
    <canvas width="150" height="150" id="ivory"></canvas>
    <canvas width="150" height="150" id="khaki"></canvas>
    <canvas width="150" height="150" id="lavender"></canvas>
    <canvas width="150" height="150" id="lavenderblush"></canvas>
    <canvas width="150" height="150" id="lawngreen"></canvas>
    <canvas width="150" height="150" id="lemonchiffon"></canvas>
    <canvas width="150" height="150" id="lightblue"></canvas>
    <canvas width="150" height="150" id="lightcoral"></canvas>
    <canvas width="150" height="150" id="lightcyan"></canvas>
    <canvas width="150" height="150" id="lightgoldenrodyellow"></canvas>
    <canvas width="150" height="150" id="lightgray"></canvas>
    <canvas width="150" height="150" id="lightgreen"></canvas>
    <canvas width="150" height="150" id="lightgrey"></canvas>
    <canvas width="150" height="150" id="lightpink"></canvas>
    <canvas width="150" height="150" id="lightsalmon"></canvas>
    <canvas width="150" height="150" id="lightseagreen"></canvas>
    <canvas width="150" height="150" id="lightskyblue"></canvas>
    <canvas width="150" height="150" id="lightslategray"></canvas>
    <canvas width="150" height="150" id="lightslategrey"></canvas>
    <canvas width="150" height="150" id="lightsteelblue"></canvas>
    <canvas width="150" height="150" id="lightyellow"></canvas>
    <canvas width="150" height="150" id="lime"></canvas>
    <canvas width="150" height="150" id="limegreen"></canvas>
    <canvas width="150" height="150" id="linen"></canvas>
    <canvas width="150" height="150" id="magenta"></canvas>
    <canvas width="150" height="150" id="maroon"></canvas>
    <canvas width="150" height="150" id="mediumaquamarine"></canvas>
    <canvas width="150" height="150" id="mediumblue"></canvas>
    <canvas width="150" height="150" id="mediumorchid"></canvas>
    <canvas width="150" height="150" id="mediumpurple"></canvas>
    <canvas width="150" height="150" id="mediumseagreen"></canvas>
    <canvas width="150" height="150" id="mediumslateblue"></canvas>
    <canvas width="150" height="150" id="mediumspringgreen"></canvas>
    <canvas width="150" height="150" id="mediumturquoise"></canvas>
    <canvas width="150" height="150" id="mediumvioletred"></canvas>
    <canvas width="150" height="150" id="midnightblue"></canvas>
    <canvas width="150" height="150" id="mintcream"></canvas>
    <canvas width="150" height="150" id="mistyrose"></canvas>
    <canvas width="150" height="150" id="moccasin"></canvas>
    <canvas width="150" height="150" id="navajowhite"></canvas>
    <canvas width="150" height="150" id="navy"></canvas>
    <canvas width="150" height="150" id="oldlace"></canvas>
    <canvas width="150" height="150" id="olive"></canvas>
    <canvas width="150" height="150" id="olivedrab"></canvas>
    <canvas width="150" height="150" id="orange"></canvas>
    <canvas width="150" height="150" id="orangered"></canvas>
    <canvas width="150" height="150" id="orchid"></canvas>
    <canvas width="150" height="150" id="palegoldenrod"></canvas>
    <canvas width="150" height="150" id="palegreen"></canvas>
    <canvas width="150" height="150" id="paleturquoise"></canvas>
    <canvas width="150" height="150" id="palevioletred"></canvas>
    <canvas width="150" height="150" id="papayawhip"></canvas>
    <canvas width="150" height="150" id="peachpuff"></canvas>
    <canvas width="150" height="150" id="peru"></canvas>
    <canvas width="150" height="150" id="pink"></canvas>
    <canvas width="150" height="150" id="plum"></canvas>
    <canvas width="150" height="150" id="powderblue"></canvas>
    <canvas width="150" height="150" id="purple"></canvas>
    <canvas width="150" height="150" id="rebeccapurple"></canvas>
    <canvas width="150" height="150" id="red"></canvas>
    <canvas width="150" height="150" id="rosybrown"></canvas>
    <canvas width="150" height="150" id="royalblue"></canvas>
    <canvas width="150" height="150" id="saddlebrown"></canvas>
    <canvas width="150" height="150" id="salmon"></canvas>
    <canvas width="150" height="150" id="sandybrown"></canvas>
    <canvas width="150" height="150" id="seagreen"></canvas>
    <canvas width="150" height="150" id="seashell"></canvas>
    <canvas width="150" height="150" id="sienna"></canvas>
    <canvas width="150" height="150" id="silver"></canvas>
    <canvas width="150" height="150" id="skyblue"></canvas>
    <canvas width="150" height="150" id="slateblue"></canvas>
    <canvas width="150" height="150" id="slategray"></canvas>
    <canvas width="150" height="150" id="slategrey"></canvas>
    <canvas width="150" height="150" id="snow"></canvas>
    <canvas width="150" height="150" id="springgreen"></canvas>
    <canvas width="150" height="150" id="steelblue"></canvas>
    <canvas width="150" height="150" id="tan"></canvas>
    <canvas width="150" height="150" id="teal"></canvas>
    <canvas width="150" height="150" id="thistle"></canvas>
    <canvas width="150" height="150" id="tomato"></canvas>
    <canvas width="150" height="150" id="turquoise"></canvas>
    <canvas width="150" height="150" id="violet"></canvas>
    <canvas width="150" height="150" id="wheat"></canvas>
    <canvas width="150" height="150" id="white"></canvas>
    <canvas width="150" height="150" id="whitesmoke"></canvas>
    <canvas width="150" height="150" id="yellow"></canvas>
    <canvas width="150" height="150" id="yellowgreen"></canvas> -->
    <script>
      const cssColorKeywords = [
        "aliceblue",
        "antiquewhite",
        "aqua",
        "aquamarine",
        "azure",
        "beige",
        "bisque",
        "black",
        "blanchedalmond",
        "blue",
        "blueviolet",
        "brown",
        "burlywood",
        "cadetblue",
        "chartreuse",
        "chocolate",
        "coral",
        "cornflowerblue",
        "cornsilk",
        "crimson",
        "cyan",
        "darkblue",
        "darkcyan",
        "darkgoldenrod",
        "darkgray",
        "darkgreen",
        "darkgrey",
        "darkkhaki",
        "darkmagenta",
        "darkolivegreen",
        "darkorange",
        "darkorchid",
        "darkred",
        "darksalmon",
        "darkseagreen",
        "darkslateblue",
        "darkslategray",
        "darkslategrey",
        "darkturquoise",
        "darkviolet",
        "deeppink",
        "deepskyblue",
        "dimgray",
        "dimgrey",
        "dodgerblue",
        "firebrick",
        "floralwhite",
        "forestgreen",
        "fuchsia",
        "gainsboro",
        "ghostwhite",
        "gold",
        "goldenrod",
        "gray",
        "green",
        "greenyellow",
        "grey",
        "honeydew",
        "hotpink",
        "indianred",
        "indigo",
        "ivory",
        "khaki",
        "lavender",
        "lavenderblush",
        "lawngreen",
        "lemonchiffon",
        "lightblue",
        "lightcoral",
        "lightcyan",
        "lightgoldenrodyellow",
        "lightgray",
        "lightgreen",
        "lightgrey",
        "lightpink",
        "lightsalmon",
        "lightseagreen",
        "lightskyblue",
        "lightslategray",
        "lightslategrey",
        "lightsteelblue",
        "lightyellow",
        "lime",
        "limegreen",
        "linen",
        "magenta",
        "maroon",
        "mediumaquamarine",
        "mediumblue",
        "mediumorchid",
        "mediumpurple",
        "mediumseagreen",
        "mediumslateblue",
        "mediumspringgreen",
        "mediumturquoise",
        "mediumvioletred",
        "midnightblue",
        "mintcream",
        "mistyrose",
        "moccasin",
        "navajowhite",
        "navy",
        "oldlace",
        "olive",
        "olivedrab",
        "orange",
        "orangered",
        "orchid",
        "palegoldenrod",
        "palegreen",
        "paleturquoise",
        "palevioletred",
        "papayawhip",
        "peachpuff",
        "peru",
        "pink",
        "plum",
        "powderblue",
        "purple",
        "rebeccapurple",
        "red",
        "rosybrown",
        "royalblue",
        "saddlebrown",
        "salmon",
        "sandybrown",
        "seagreen",
        "seashell",
        "sienna",
        "silver",
        "skyblue",
        "slateblue",
        "slategray",
        "slategrey",
        "snow",
        "springgreen",
        "steelblue",
        "tan",
        "teal",
        "thistle",
        "tomato",
        "turquoise",
        "violet",
        "wheat",
        "white",
        "whitesmoke",
        "yellow",
        "yellowgreen",
        ];

        // Code to generate color squares for instagram images
        // for (let i = 0; i < cssColorKeywords.length; i++) {

        //   const canvas = document.getElementById(cssColorKeywords[i]);
        //   const ctx = canvas.getContext('2d');

        //   ctx.fillStyle = cssColorKeywords[i];
        //   ctx.fillRect(0, 0, 150, 150);

        // }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width = 0;
        for (let i = 0; i < cssColorKeywords.length; i++) {

          ctx.fillStyle = cssColorKeywords[i];
          // start
          ctx.fillRect(i + width, 0, width, 1000);

          width += 6.8027210884;

        }

        /*!
    canvas-to-tiff version 1.0.0
    By Epistemex (c) 2015-2016
    www.epistemex.com
    MIT License (this header required)
  */

          /**
           * Static helper object that can convert a CORS-compliant canvas element
           * to a 32-bits TIFF file (buffer, Blob and data-URI). The TIFF is by
           * default saved in big-endian format with interleaved RGBA data.
           *
           * @type {{toArrayBuffer: Function, toBlob: Function, toDataURL: Function}}
           * @namespace
           */
          var CanvasToTIFF = {

            /**
             * @private
             */
            _dly: 9,

            /**
             * @private
             */
            _error: null,

            /**
             * Add error handler (function) in case of any error
             * @param fn
             */
            setErrorHandler: function (fn) {
              this._error = fn
            },

            /**
             * Convert a canvas element to ArrayBuffer containing a TIFF file
             * with support for alpha. The call is asynchronous
             * so a callback must be provided.
             *
             * Note that CORS requirement must be fulfilled.
             *
             * @param {HTMLCanvasElement} canvas - the canvas element to convert
             * @param {function} callback - called when conversion is done. Argument is ArrayBuffer
             * @param {object} [options] - an option object
             * @param {boolean} [options.littleEndian=false] - set to true to produce a little-endian based TIFF
             * @param {number} [options.dpi=96] - DPI for both X and Y directions. Default 96 DPI (PPI).
             * @param {number} [options.dpiX=96] - DPI for X directions (overrides options.dpi).
             * @param {number} [options.dpiY=96] - DPI for Y directions (overrides options.dpi).
             * @static
             */
            toArrayBuffer: function (canvas, callback, options) {

              options = options || {};

              var me = this;

              try {
                var w = canvas.width,
                  h = canvas.height,
                  offset = 0,
                  iOffset = 258, // todo calc based on offset field length, add to final offset when compiled
                  //iOffsetPtr,
                  entries = 0,
                  offsetList = [],
                  idfOffset,
                  sid = "\x63\x61\x6e\x76\x61\x73\x2d\x74\x6f\x2d\x74\x69\x66\x66\x20\x30\x2e\x34\0",
                  lsb = !!options.littleEndian,
                  dpiX = +(options.dpiX || options.dpi || 96) | 0,
                  dpiY = +(options.dpiY || options.dpi || 96) | 0,
                  idata = canvas.getContext("2d").getImageData(0, 0, w, h),
                  length = idata.data.length,
                  fileLength = iOffset + length,
                  file = new ArrayBuffer(fileLength),
                  file8 = new Uint8Array(file),
                  view = new DataView(file),
                  pos = 0,
                  date = new Date(),
                  dateStr;

                // Header
                set16(lsb ? 0x4949 : 0x4d4d);							// II or MM
                set16(42);												// magic 42
                set32(8);												// offset to first IFD

                // IFD
                addIDF();												// IDF start
                addEntry(0xfe, 4, 1, 0);								// NewSubfileType
                addEntry(0x100, 4, 1, w);								// ImageWidth
                addEntry(0x101, 4, 1, h);								// ImageLength (height)
                addEntry(0x102, 3, 4, offset, 8);						// BitsPerSample
                addEntry(0x103, 3, 1, 1);								// Compression
                addEntry(0x106, 3, 1, 2);								// PhotometricInterpretation: RGB
                addEntry(0x111, 4, 1, iOffset, 0);						// StripOffsets
                addEntry(0x115, 3, 1, 4);								// SamplesPerPixel
                addEntry(0x117, 4, 1, length);							// StripByteCounts
                addEntry(0x11a, 5, 1, offset, 8);						// XResolution
                addEntry(0x11b, 5, 1, offset, 8);						// YResolution
                addEntry(0x128, 3, 1, 2);								// ResolutionUnit: inch
                addEntry(0x131, 2, sid.length, offset, getStrLen(sid));	// sid
                addEntry(0x132, 2, 0x14, offset, 0x14);					// Datetime
                addEntry(0x152, 3, 1, 2);								// ExtraSamples
                endIDF();

                // Fields section > long ---------------------------

                // BitsPerSample (2x4), 8,8,8,8
                set32(0x00080008);
                set32(0x00080008);

                // StripOffset to bitmap data
                //set32(iOffset);

                // StripByteCounts
                //set32(length);

                // XRes PPI
                set32(dpiX);
                set32(1);

                // YRes PPI
                set32(dpiY);
                set32(1);

                // sid
                setStr(sid);

                // date
                dateStr = date.getFullYear() + ":" + pad2(date.getMonth() + 1) + ":" + pad2(date.getDate()) + " ";
                dateStr += pad2(date.getHours()) + ":" + pad2(date.getMinutes()) + ":" + pad2(date.getSeconds());
                setStr(dateStr);

                // Image data here (todo if very large, split into block based copy)
                file8.set(idata.data, iOffset);

                // make actual async
                setTimeout(function () { callback(file) }, me._dly);
              }
              catch (err) {
                if (me._error) me._error(err.toString())
              }

              function pad2(str) {
                str += "";
                return str.length === 1 ? "0" + str : str
              }

              // helper method to move current buffer position
              function set16(data) {
                view.setUint16(pos, data, lsb);
                pos += 2
              }

              function set32(data) {
                view.setUint32(pos, data, lsb);
                pos += 4
              }

              function setStr(str) {
                var i = 0;
                while (i < str.length) view.setUint8(pos++, str.charCodeAt(i++) & 0xff, lsb);
                if (pos & 1) pos++
              }

              function getStrLen(str) {
                var l = str.length;
                return l & 1 ? l + 1 : l
              }

              function addEntry(tag, type, count, value, dltOffset) {
                set16(tag);
                set16(type);
                set32(count);

                if (dltOffset) {
                  //if (tag === 0x111) iOffsetPtr = pos;
                  //iOffset += dltOffset;
                  offset += dltOffset;
                  offsetList.push(pos);
                }

                if (count === 1 && type === 3 && !dltOffset) {
                  set16(value);
                  set16(0);	// pad
                }
                else {
                  set32(value);
                }

                entries++
              }

              function addIDF(offset) {
                idfOffset = offset || pos;
                pos += 2;
              }

              function endIDF() {
                view.setUint16(idfOffset, entries, lsb);
                set32(0);

                var delta = 14 + entries * 12; // 14 = offset to IDF (8) + IDF count (2) + end pointer (4)

                // compile offsets
                for (var i = 0, p, o; i < offsetList.length; i++) {
                  p = offsetList[i];
                  o = view.getUint32(p, lsb);
                  view.setUint32(p, o + delta, lsb);
                }

                //view.setUint32(iOffsetPtr, iOffset + delta, lsb);
              }
            },

            /**
             * Converts a canvas to TIFF file, returns a Blob representing the
             * file. This can be used with URL.createObjectURL(). The call is
             * asynchronous so a callback must be provided.
             *
             * Note that CORS requirement must be fulfilled.
             *
             * @param {HTMLCanvasElement} canvas - the canvas element to convert
             * @param {function} callback - called when conversion is done. Argument is a Blob
             * @param {object} [options] - an option object - see toArrayBuffer for details
             * @static
             */
            toBlob: function (canvas, callback, options) {
              this.toArrayBuffer(canvas, function (file) {
                callback(new Blob([file], { type: "image/tiff" }));
              }, options || {});
            },

            /**
             * Converts a canvas to TIFF file, returns an ObjectURL (for Blob)
             * representing the file. The call is asynchronous so a callback
             * must be provided.
             *
             * **Important**: To avoid memory-leakage you must revoke the returned
             * ObjectURL when no longer needed:
             *
             *     var _URL = self.URL || self.webkitURL || self;
             *     _URL.revokeObjectURL(url);
             *
             * Note that CORS requirement must be fulfilled.
             *
             * @param {HTMLCanvasElement} canvas - the canvas element to convert
             * @param {function} callback - called when conversion is done. Argument is a Blob
             * @param {object} [options] - an option object - see toArrayBuffer for details
             * @static
             */
            toObjectURL: function (canvas, callback, options) {
              this.toBlob(canvas, function (blob) {
                var url = self.URL || self.webkitURL || self;
                callback(url.createObjectURL(blob))
              }, options || {});
            },

            /**
             * Converts the canvas to a data-URI representing a BMP file. The
             * call is asynchronous so a callback must be provided.
             *
             * Note that CORS requirement must be fulfilled.
             *
             * @param {HTMLCanvasElement} canvas - the canvas element to convert
             * @param {function} callback - called when conversion is done. Argument is an data-URI (string)
             * @param {object} [options] - an option object - see toArrayBuffer for details
             * @static
             */
            toDataURL: function (canvas, callback, options) {

              var me = this;

              me.toArrayBuffer(canvas, function (file) {
                var buffer = new Uint8Array(file),
                  blockSize = 1 << 20,
                  block = blockSize,
                  bs = "", base64 = "", i = 0, l = buffer.length;

                // This is a necessary step before we can use btoa. We can
                // replace this later with a direct byte-buffer to Base-64 routine.
                // Will do for now, impacts only with very large bitmaps (in which
                // case toBlob should be used).
                (function prepBase64() {
                  while (i < l && block-- > 0) bs += String.fromCharCode(buffer[i++]);

                  if (i < l) {
                    block = blockSize;
                    setTimeout(prepBase64, me._dly);
                  }
                  else {
                    // convert string to Base-64
                    i = 0;
                    l = bs.length;
                    block = 180000;		// must be divisible by 3

                    (function toBase64() {
                      base64 += btoa(bs.substr(i, block));
                      i += block;
                      (i < l)
                        ? setTimeout(toBase64, me._dly)
                        : callback("data:image/tiff;base64," + base64);
                    })();
                  }
                })();
              }, options || {});
            }
          };

        CanvasToTIFF.toDataURL(canvas, function (url) {
          var a = document.querySelector("a");
          a.href = url;
          a.innerHTML = "Right-click this link, select Save As to save the TIFF";
        })

        // CanvasToTIFF.toDataURL(canvas, function (url) {
        //   // url now contains the data-uri.
        //   window.location = url;    // download, does not work in IE; just to demo
        // });

    </script>
  </body>
</html>